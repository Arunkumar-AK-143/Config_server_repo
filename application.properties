// src/app/tickets/my-tickets/my-tickets.component.ts
import { Component, OnInit } from '@angular/core';
import { TicketService } from '../../services/ticket.service';
import { Ticket } from '../../models/ticket.model';
import { AuthService } from '../../services/auth.service';
import { EventService } from '../../services/event.service';
import { Event } from '../../models/event.model';
import { combineLatest, switchMap, map } from 'rxjs';

@Component({
  selector: 'app-my-tickets',
  templateUrl: './my-tickets.component.html',
  standalone:false,
  styleUrls: ['./my-tickets.component.css']
})
export class MyTicketsComponent implements OnInit {
  myTickets: Ticket[] = [];
  userId: number | null = null;
  errorMessage: string = '';
  eventsMap: { [key: number]: Event } = {}; // To store event details for display

  constructor(
    private ticketService: TicketService,
    private authService: AuthService,
    private eventService: EventService
  ) { }

  ngOnInit(): void {
    this.authService.getCurrentUserId().pipe(
      switchMap(id => {
        this.userId = id;
        if (id) {
          return this.ticketService.getTicketsByUserId(id); //[cite: 36]
        } else {
          this.errorMessage = 'You must be logged in to view your tickets.';
          return []; // Return empty array if not logged in
        }
      }),
      switchMap(tickets => {
        this.myTickets = tickets;
        
        const eventIds = new Set(tickets.map(ticket => ticket.eventId));
        
        const eventObservables = Array.from(eventIds).map(eventId => this.eventService.getEventById(eventId)); //[cite: 11]
        return combineLatest(eventObservables).pipe(
          map(events => {
            events.forEach(event => {
              if (event.id) {
                this.eventsMap[event.id] = event;
                
              }
            });
            return tickets;
          })
        );
      })
    ).subscribe({
      next: () => {}, // Data already set in switchMap
      error: (err) => {
        console.error('Error fetching tickets or events:', err);
        this.errorMessage = 'Failed to load your tickets. ' + (err.error || 'Please try again.');
      }
    });
  }

  // getEventId(eventId: number): string {
  //   return this.eventsMap[eventId]?.name || 'Loading...';
  // }

  onCancelTicket(ticketId: number | undefined): void {
    if (ticketId && confirm('Are you sure you want to cancel this ticket?')) {
      this.ticketService.cancelTicket(ticketId).subscribe({   //[cite: 38]
        next: (updatedTicket) => {
          console.log('Ticket cancelled:', updatedTicket);
          alert(`Ticket ${ticketId} has been ${updatedTicket.status}.`);
          // Update the status locally or reload tickets
          const index = this.myTickets.findIndex(t => t.id === ticketId);
          if (index !== -1) {
            this.myTickets[index].status = updatedTicket.status;
          }
        },
        error: (err) => {
          console.error('Error cancelling ticket:', err);
          this.errorMessage = 'Failed to cancel ticket: ' + (err.error || 'Please try again.');
        }
      });
    }
  }
}

// import { Injectable, Inject, PLATFORM_ID } from '@angular/core';
// import { HttpClient } from '@angular/common/http';
// import { Observable, of } from 'rxjs';
// import { isPlatformBrowser } from '@angular/common';

// @Injectable({ providedIn: 'root' })
// export class AuthService {
//   hasRole: any;
//   currentUser: any;
//   // isAdmin(): boolean {
//   //   return this.hasRole('ADMIN')
//   // }
//   private apiUrl = 'http://localhost:2061/auth';

//   constructor(
//     private http: HttpClient,
//     @Inject(PLATFORM_ID) private platformId: Object
//   ) {}

//   login(credentials: any): Observable<string> {
//     return this.http.post(`${this.apiUrl}/login`, credentials, { responseType: 'text' });
    
//   }

//   register(user: any): Observable<string> {
//     return this.http.post(`${this.apiUrl}/register`, user, { responseType: 'text' });
//   }

//   getToken(): string | null {
//     if (isPlatformBrowser(this.platformId)) {
//       return localStorage.getItem('jwtToken');
//     }
//     return null;
//   }

//   isLoggedIn(): Observable<boolean> {
//     return of(!!this.getToken());
//   }

//   logout(): void {
//     if (isPlatformBrowser(this.platformId)) {
//       localStorage.removeItem('jwtToken');
//     }
//   }

//   getUserRole(): Observable<string | null> {
//     const token = this.getToken();
//     if (!token) return of(null);
  
//     const payload = JSON.parse(atob(token.split('.')[1]));
//     const roles = payload.roles;
  
//     // Check structure: role might be an array of authorities
//     if (Array.isArray(roles)) {
//       // If first item is object: { authority: "ROLE_USER" }
//       if (typeof roles[0] === 'object' && roles[0] !== null) {
//         return of(roles[0].authority || null);
//       } else {
//         return of(roles[0]);
//       }
//     }
  
//     return of(null);
//   }

//   getCurrentUserId(): Observable<number | null> {
//     const token = this.getToken();
//     if (!token) return of(null);
//     const payload = JSON.parse(atob(token.split('.')[1]));
//     const sub = payload.sub;
//     return of(isNaN(Number(sub)) ? null : Number(sub));
//   }
// }
//=============================================================================================



// src/app/services/auth.service.ts
import { Injectable, Inject, PLATFORM_ID } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of } from 'rxjs';
import { isPlatformBrowser } from '@angular/common';

@Injectable({ providedIn: 'root' })
export class AuthService {
  // Removed unused properties 'hasRole' and 'currentUser'
  private apiUrl = 'http://localhost:2061/auth';

  constructor(
    private http: HttpClient,
    @Inject(PLATFORM_ID) private platformId: Object
  ) {}

  login(credentials: any): Observable<string> {
    return this.http.post(`${this.apiUrl}/login`, credentials, { responseType: 'text' });
  }

  register(user: any): Observable<string> {
    return this.http.post(`${this.apiUrl}/register`, user, { responseType: 'text' });
  }

  getToken(): string | null {
    if (isPlatformBrowser(this.platformId)) {
      return localStorage.getItem('jwtToken');
    }
    return null;
  }

  isLoggedIn(): Observable<boolean> {
    return of(!!this.getToken());
  }

  logout(): void {
    if (isPlatformBrowser(this.platformId)) {
      localStorage.removeItem('jwtToken');
    }
  }

  // getUserRole(): Observable<string | null> {
  //   const token = this.getToken();
  //   if (!token) return of(null);

  //   try {
  //     const payload = JSON.parse(atob(token.split('.')[1]));
  //     const roles = payload.roles;

  //     if (Array.isArray(roles) && roles.length > 0) {
  //       if (typeof roles[0] === 'object' && roles[0] !== null && 'authority' in roles[0]) {
  //         return of(roles[0].authority);
  //       } else {
  //         return of(roles[0]);
  //       }
  //     }
  //   } catch (e) {
  //     console.error('Error decoding or parsing JWT token for role:', e);
  //   }
  //   return of(null);
  // }
  // getUserRole(): Observable<string | null> {
  //   const token = localStorage.getItem('jwtToken');
  //   if (!token) return of(null);
  
  //   try {
  //     const payload = JSON.parse(atob(token.split('.')[1]));
  //     return of(payload.role || null);
  //   } catch (e) {
  //     console.error('Failed to decode token', e);
  //     return of(null);
  //   }
  // }


  getUserRole(): Observable<string | null> {
    if (!isPlatformBrowser(this.platformId)) {
      return of(null); // SSR fallback
    }

    const token = localStorage.getItem('jwtToken');
    if (!token) return of(null);

    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      return of(payload.role || null);
    } catch (e) {
      console.error('Failed to decode token', e);
      return of(null);
    }
  }
//   getCurrentUserId(): Observable<number | null> {
//     const token = this.getToken();
//     if (!token) return of(null);
//     try {
//       const payload = JSON.parse(atob(token.split('.')[1]));
//       const userIdFromToken = payload.sub || payload.id; // Use 'sub' or 'id' based on your backend JWT
//       return of(isNaN(Number(userIdFromToken)) ? null : Number(userIdFromToken));
//     } catch (e) {
//       console.error('Error decoding or parsing JWT token for userId:', e);
//     }
//     return of(null);
//   }
// }

getCurrentUserId(): Observable<number | null> {
  const token = localStorage.getItem('jwtToken');
  if (!token) return of(null);

  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    return of(payload.userId || null);
  } catch (e) {
    console.error('Failed to decode JWT:', e);
    return of(null);
  }
}
}



